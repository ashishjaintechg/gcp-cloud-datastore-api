package com.db.cloud.dao;


import java.util.ArrayList;
import java.util.List;

import com.db.cloud.exception.CloudDatastoreDAOException;
import com.db.cloud.model.Result;
import com.db.cloud.util.CloudDatastoreRefUtil;
import com.google.cloud.datastore.BaseEntity;
import com.google.cloud.datastore.Cursor;
import com.google.cloud.datastore.Datastore;
import com.google.cloud.datastore.DatastoreOptions;
import com.google.cloud.datastore.Entity;
import com.google.cloud.datastore.Entity.Builder;
import com.google.cloud.datastore.FullEntity;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.KeyFactory;
import com.google.cloud.datastore.Query;
import com.google.cloud.datastore.QueryResults;
import com.google.cloud.datastore.StructuredQuery.CompositeFilter;
import com.google.cloud.datastore.StructuredQuery.Filter;
import com.google.cloud.datastore.StructuredQuery.OrderBy;
import com.google.cloud.datastore.StructuredQuery.PropertyFilter;
import com.google.datastore.v1.QueryResultBatch;

/**
 * This abstract class CloudDatastoreDAOImpl is implementation of all cloud data store common operations.
 *
 * @author Ashish Jain
 * @version 1.0 
 * @date 13-DEC-2018
 *
 * @param <T> This parameter will have different model objects at run time.
 */
/**
 * @author asjain
 *
 * @param <T>
 */

public abstract class CloudDatastoreDAOImpl<T> implements CloudDatastoreDAO<T> {

	/**
	 * This datastore variable holds data store service.
	 */
	private Datastore datastore = null;
	/**
	 * This keyFactory variable provides keys functionality for Create, Read, Update
	 * and Delete operation on data store.
	 */
	private KeyFactory keyFactory;
	/**
	 * This reflectionUtil provides creation of objects at run time by Reflection
	 * JAVA API. Core functionality includes : 1. Converting Model to Data store
	 * Builder For Add/Update Operations. 2. Converting Data store Entity to Model
	 * object For Get Operation.
	 * 
	 */
	private CloudDatastoreRefUtil reflectionUtil;
	/**
	 * This modelClass generates model class types at runtime.
	 */
	private Class<?> modelClassType;

	/**
	 * This datastoreKind refers to data store table name.
	 */
	private String datastoreKind;

	/**
	 * This getDatastoreService method returns instance of data store service.
	 * 
	 * @return Datastore
	 */
	public Datastore getDatastoreService() {
		try {
			datastore = DatastoreOptions.getDefaultInstance().getService();
			//System.out.println("Recieved datastore service object : "+datastore);

		} catch (Exception e) {
			System.err.println(
					"DATA STORE INITIALIZATION EXCEPTION : " + this.getClass().getName() + " : " + e.getMessage());
		}
		return datastore;
	}

	/**
	 * This CloudDatastoreDAOImpl constructor instantiate data store services and
	 * other instance variable with passed parameters.
	 * 
	 * @param modelClassType
	 */
	protected CloudDatastoreDAOImpl(Class<?> modelClassType) {
		this.datastoreKind = modelClassType.getSimpleName();
		this.keyFactory = getDatastoreService().newKeyFactory().setKind(datastoreKind);
		this.modelClassType = modelClassType;
		this.reflectionUtil = new CloudDatastoreRefUtil();
	}

	/**
	 * This getDatastoreKind method returns data store table name.
	 * 
	 * @return String - Data store table name
	 */
	private String getDatastoreKind() {
		return datastoreKind;
	}

	/**
	 * This getKeyFactory method provides KeyFactory instance which helps in keys
	 * related opeation on data store.
	 * 
	 * @return KeyFactory
	 */
	private KeyFactory getKeyFactory() {
		return keyFactory;
	}

	/**
	 * This getModelClassType method returns model class types used for invoking
	 * setters and getters and set the states.
	 * 
	 * @return Class - Model class type
	 */
	private Class<?> getModelClassType() {
		return modelClassType;
	}

	@SuppressWarnings("unchecked")
	@Override
	/**
	 * This findById method returns generic model object as per passed key
	 * parameter. It uses utility for converting data store entity to model and set
	 * the states.
	 * 
	 * @param Long id - Key of data store table
	 * @return T - Model Object
	 */
	public T findById(Long id) {
		Entity entity = getDatastoreService().get(getKeyFactory().newKey(id));
		if (entity == null)
			return null;

		Object object = reflectionUtil.setEntityToModel(getModelClassType(), entity);
		return (T) object;
	}

	@SuppressWarnings("rawtypes")
	@Override
	/**
	 * This add method performs two functionality. It uses utility for converting
	 * model to data store entity and set the states. 1. If client has generated key
	 * then same key is used in data store table as a key. 2 If client has not
	 * generated key then new key is generated by this add method.
	 * 
	 * @param T t - Generic Type Model object
	 */
	public Long add(T t) {
		Object obj = reflectionUtil.setModelToEntityBuilder(getKeyFactory(), t, true);
		if (obj == null)
			return null;

		return getDatastoreService().add((FullEntity<?>) ((BaseEntity.Builder) obj).build()).getKey().getId();
	}

	@Override
	/**
	 * This update method updates model object coming in generic type t as a
	 * parameter in data store table. It uses utility for converting model to data
	 * store entity and set the states.
	 * 
	 * @param T t - Generic Type Model object
	 */
	public void update(T t) {
		Builder builder = (Builder) reflectionUtil.setModelToEntityBuilder(getKeyFactory(), t, false);
		if (builder == null)
			return;
		getDatastoreService().update(builder.build());
	}

	@Override
	/**
	 * This delete method deletes entity from data store table on the basis of key
	 * id parameter passed.
	 * 
	 * @param Long id - Data store table unique key
	 */
	public void delete(Long id) {
		getDatastoreService().delete(getKeyFactory().newKey(id));
	}

	@Override
	/**
	 * This getByParam method returns List of generic model objects on the basis of
	 * table column name and matching criteria passed as a value. It uses utility
	 * for converting data store entity to model and set the states.
	 * 
	 * @param String column - Data store table column
	 * @param String value - Column matching value
	 * @return List<T> -List of Model objects
	 */
	@SuppressWarnings("unchecked")
	public List<T> getByParam(String column, String value) {
		List<T> tlist = new ArrayList<>();
		Query<Entity> query = Query.newEntityQueryBuilder().setKind(getDatastoreKind())
				.setFilter(CompositeFilter.and(PropertyFilter.eq(column, value))).build();
		QueryResults<Entity> entities = getDatastoreService().run(query);
		if (entities == null)
			return null;
		while (entities.hasNext()) {
			Entity entity = entities.next();
			T object = (T) reflectionUtil.setEntityToModel(getModelClassType(), entity);
			tlist.add(object);
		}
		return tlist;
	}

	@Override
	/**
	 * This getByParam method returns List of generic model objects on the basis of
	 * table column name and matching criteria passed as a value. It uses utility
	 * for converting data store entity to model and set the states.
	 * 
	 * @param String column - Data store table column
	 * @param Long   value - Column matching value
	 * @return List<T> -List of Model objects
	 */
	@SuppressWarnings("unchecked")
	public List<T> getByParam(String column, Long value) {
		List<T> tlist = new ArrayList<>();
		Query<Entity> query = Query.newEntityQueryBuilder().setKind(getDatastoreKind())
				.setFilter(CompositeFilter.and(PropertyFilter.eq(column, value))).build();
		QueryResults<Entity> entities = getDatastoreService().run(query);
		if (entities == null)
			return null;
		while (entities.hasNext()) {
			Entity entity = entities.next();
			T object = (T) reflectionUtil.setEntityToModel(getModelClassType(), entity);
			tlist.add(object);
		}
		return tlist;
	}

//	@Override
//	/**
//	 * This getByParam method returns List of generic model objects on the basis of filter criteria passed. It uses utility for converting data store entity to model and set the states. 
//	 * @param Filter filter - Condition basis rows will be retrieved
//	 * @return List<T> -List of Model objects
//	 */	
//	public List<T> getByFields(Filter filter)
//	{
//		return getByFields(filter, null);
//	}

	@Override
	/**
	 * This findUniqueBy method returns generic unique model objects on the basis of
	 * filter criteria passed. It uses utility for converting data store entity to
	 * model and set the states.
	 * 
	 * @param Filter filter - Condition basis rows will be retrieved
	 * @return T -Model objects
	 */
	public T findUniqueBy(Filter filter) {
		List<T> dataList = getByFields(filter);
		if (dataList == null || dataList.isEmpty())
			return null;
		if (dataList.size() > 1)
			throw new CloudDatastoreDAOException("Too many records");
		return dataList.get(0);

	}

	@Override
	/**
	 * This findAll method returns List of generic model objects on the basis of
	 * filter criteria passed. It uses utility for converting data store entity to
	 * model and set the states.
	 * 
	 * @param Filter filter - Condition basis rows will be retrieved
	 * @return List<T> -List of Model objects
	 */
	public List<T> findAll(Filter filter) {
		return getByFields(filter);
	}

	@Override
	/**
	 * This getByFields method returns List of generic model objects on the basis of
	 * first filter and remaining multiple filters criteria passed. It uses utility
	 * for converting data store entity to model and set the states.
	 * 
	 * @param Filter firstFilter - Single filter Conditions basis rows will be
	 *               retrieved.
	 * @param        Filter... remainingFilter - Multiple Conditions basis rows will
	 *               be retrieved.
	 * @return List<T> -List of Model objects
	 */
	@SuppressWarnings("unchecked")
	public List<T> getByFields(Filter firstFilter, Filter... remainingFilter) {
		if (firstFilter == null)
			return null;

		CompositeFilter compositeFilter = null;
		if (remainingFilter == null || remainingFilter.length == 0) {
			compositeFilter = CompositeFilter.and(firstFilter);
		} else {
			compositeFilter = CompositeFilter.and(firstFilter, remainingFilter);
		}
		Query<Entity> query = Query.newEntityQueryBuilder().setKind(getDatastoreKind()).setFilter(compositeFilter)
				.build();
		query.toString();
		QueryResults<Entity> entities = getDatastoreService().run(query);
		if (entities == null)
			return null;
		List<T> tlist = new ArrayList<>();
		while (entities.hasNext()) {
			Entity entity = entities.next();
			T object = (T) reflectionUtil.setEntityToModel(getModelClassType(), entity);
			tlist.add(object);
		}
		return tlist;
	}

	/**
	 * This method deletes multiple entities from data store table on the basis of
	 * array of key id parameters passed.
	 * 
	 * @param Long id - Data store table unique key
	 */
	@Override
	public void delete(Long[] ids) {

		if (ids == null || ids.length == 0)
			return;

		List<Key> keys = new ArrayList<>();
		for (Long id : ids) {
			if (id != null)
				keys.add(getKeyFactory().newKey(id));
		}

		if (keys.isEmpty())
			return;
		Key[] keysArray = null;
		if (keys.size() > 0) {
			keysArray = keys.toArray(new Key[keys.size()]);
			getDatastoreService().delete(keysArray);
		}
	}

	/**
	 * This add method performs two functionality. It uses utility for converting
	 * model to data store entity and set the states. 1. If client has generated key
	 * then same key is used in data store table as a key. 2 If client has not
	 * generated key then new key is generated by this add method.
	 * 
	 * @param T t - Generic Type Model object
	 */
	@Override
	public Long[] add(T[] t) {

		if (t == null || t.length == 0)
			return null;

		List<Long> ids = new ArrayList<>();
		List<FullEntity<?>> fullEntities = new ArrayList<>();

		for (T x : t) {
			if (x == null)
				continue;
			Object obj = reflectionUtil.setModelToEntityBuilder(getKeyFactory(), x, true);
			if (obj == null)
				continue;
			fullEntities.add((FullEntity<?>) ((BaseEntity.Builder) obj).build());
		}
		if (fullEntities.isEmpty())
			return null;

		FullEntity<?>[] fullEntityArray = fullEntities.toArray(new FullEntity[fullEntities.size()]);
		List<Entity> entities = getDatastoreService().add(fullEntityArray);
		if (entities == null || entities.isEmpty())
			return null;

		for (Entity entity : entities) {
			ids.add(entity.getKey().getId());
		}

		Long[] longArray = null;
		if (ids.size() > 0) {
			longArray = new Long[ids.size()];
			longArray = ids.toArray(longArray);
		}
		return longArray;
	}

	@Override
	/**
	 * This update method updates model object coming in generic type t as a
	 * parameter in data store table. It uses utility for converting model to data
	 * store entity and set the states.
	 * 
	 * @param T t - Generic Type Model object
	 */
	public void update(T[] t) {

		if (t == null || t.length == 0)
			return;
		List<Entity> entityList = new ArrayList<>();
		for (T x : t) {
			if (x == null)
				continue;
			Builder builder = (Builder) (reflectionUtil.setModelToEntityBuilder(getKeyFactory(), x, false));
			if (builder != null) {
				entityList.add(builder.build());
			}
		}

		if (entityList.isEmpty()) {
			return;
		}

		Entity[] entityArray = new Entity[entityList.size()];
		entityArray = entityList.toArray(entityArray);
		getDatastoreService().update(entityArray);

	}

	/**
	 * This queryPage method returns Result object having cursor for next time
	 * querying and list of current result set of model type T sent on the basis of
	 * parameters sent.
	 * 
	 * @param Integer pageSize - This parameter is for pagination. It gives records
	 *                as per limit passed.
	 * @param String  orderBy - This parameter specifies column name for which
	 *                ordering will be done.
	 * @param         boolean isAscending - This parameter specifies ascending or
	 *                descending ordering.
	 * @param String  cursor - This parameter sets the start cursor point.
	 * @param Filter  firstFilter - This parameter specifies filter criteria based
	 *                which result is required.
	 * @param         Filter... remainingFiltersr - This parameter specifies filter
	 *                criteria based which result is required.
	 * @return Result<T> - It returns list of specified model type and reference of
	 *         cursor for querying next time in case of pagination.
	 */
	@SuppressWarnings("unchecked")
	public Result<T> queryPage(Integer pageSize, String orderBy, boolean isAscending, String cursor, Filter firstFilter,
			Filter... remainingFilters) {

		com.google.cloud.datastore.EntityQuery.Builder queryBuilder = Query.newEntityQueryBuilder()
				.setKind(getDatastoreKind());

		// limit query results to specified page size
		if (pageSize != null)
			queryBuilder = queryBuilder.setLimit(pageSize);

		// add sort order to query
		if (orderBy != null && !orderBy.equals(""))
			if (isAscending)
				queryBuilder = queryBuilder.setOrderBy(OrderBy.asc(orderBy));
			else
				queryBuilder = queryBuilder.setOrderBy(OrderBy.desc(orderBy));

		// add filter to query
		CompositeFilter compositeFilter = null;
		if (remainingFilters == null || remainingFilters.length == 0) {
			compositeFilter = CompositeFilter.and(firstFilter);
		} else {
			compositeFilter = CompositeFilter.and(firstFilter, remainingFilters);
		}

		queryBuilder = queryBuilder.setFilter(compositeFilter);

		// add cursor to query
		Cursor startCursor = null;
		if (cursor != null && !cursor.equals("")) {
			startCursor = Cursor.fromUrlSafe(cursor); // Where we left off
		}
		queryBuilder = queryBuilder.setStartCursor(startCursor);

		// run query
		QueryResults<Entity> entities = getDatastoreService().run(queryBuilder.build());
		if (entities == null)
			return null;
		List<T> tlist = new ArrayList<>();
		while (entities.hasNext()) {
			Entity entity = entities.next();
			T object = (T) reflectionUtil.setEntityToModel(getModelClassType(), entity);
			tlist.add(object);
		}

		// get results
		Cursor nextCursor = entities.getCursorAfter();
		if (nextCursor != null && tlist.size() == pageSize) {
			String cursorString = nextCursor.toUrlSafe();
			return new Result<T>(tlist, cursorString);
		} else {
			return new Result<T>(tlist);
		}

	}

	/**
	 * This queryIterable method returns ResultIterator object of model type T sent
	 * on the basis of parameters sent.
	 * 
	 * @param Integer pageSize - This parameter is for pagination. It gives records
	 *                as per limit passed.
	 * @param String  orderBy - This parameter specifies column name for which
	 *                ordering will be done.
	 * @param         boolean isAscending - This parameter specifies ascending or
	 *                descending ordering.
	 * @param String  cursor - This parameter sets the start cursor point.
	 * @param Filter  firstFilter - This parameter specifies filter criteria based
	 *                which result is required.
	 * @param         Filter... remainingFiltersr - This parameter specifies filter
	 *                criteria based which result is required.
	 * @return Result<T> - It returns list of specified model type and reference of
	 *         cursor for querying next time in case of pagination.
	 */
	@SuppressWarnings("unchecked")
	public ResultIterator<T> queryIterable(Integer pageSize, String orderBy, boolean isAscending, String cursor,
			Filter firstFilter, Filter... remainingFilters) {

		com.google.cloud.datastore.EntityQuery.Builder queryBuilder = Query.newEntityQueryBuilder()
				.setKind(getDatastoreKind());

		// limit query results to specified page size
		if (pageSize != null)
			queryBuilder = queryBuilder.setLimit(pageSize);

		// add sort order to query
		if (orderBy != null && !orderBy.equals(""))
			if (isAscending)
				queryBuilder = queryBuilder.setOrderBy(OrderBy.asc(orderBy));
			else
				queryBuilder = queryBuilder.setOrderBy(OrderBy.desc(orderBy));

		// add filter to query
		CompositeFilter compositeFilter = null;
		if (remainingFilters == null || remainingFilters.length == 0) {
			compositeFilter = CompositeFilter.and(firstFilter);
		} else {
			compositeFilter = CompositeFilter.and(firstFilter, remainingFilters);
		}

		queryBuilder = queryBuilder.setFilter(compositeFilter);

		// add cursor to query
		Cursor startCursor = null;
		if (cursor != null && !cursor.equals("")) {
			startCursor = Cursor.fromUrlSafe(cursor); // Where we left off
		}
		queryBuilder = queryBuilder.setStartCursor(startCursor);

		// run query
		QueryResults<Entity> entities = getDatastoreService().run(queryBuilder.build());
		if (entities == null)
			return null;

		return new ResultIterator<T>(entities);

	}

	/**
	 * This method returns total entities available in data store kind.
	 * 
	 * @return
	 */
	public int countEntities() {
		int numberOfEntities = 0;
		Query<Key> query = Query.newKeyQueryBuilder().setKind(getDatastoreKind()).setOffset(Integer.MAX_VALUE).build();
		QueryResults<Key> result = getDatastoreService().run(query);
		if (!result.hasNext()) {
			numberOfEntities = result.getSkippedResults();
		}
		return numberOfEntities;
	}

	/**
	 * This ResultIterator iterator provides a way to iterate result from data
	 * store. While iterating it also uses converter for converting data store
	 * Entity to Model.
	 * 
	 */
	@SuppressWarnings("unchecked")
	protected class ResultIterator<T> implements QueryResults<T> {
		private final QueryResults<Entity> iterator;

		protected ResultIterator(QueryResults<Entity> iterator) {
			this.iterator = iterator;
		}

		@Override
		public boolean hasNext() {
			return this.iterator.hasNext();
		}

		@Override
		public T next() {
			return (T) reflectionUtil.setEntityToModel(getModelClassType(), this.iterator.next());
		}

		@Override
		public Class<?> getResultClass() {
			return this.iterator.getResultClass();
		}

		@Override
		public Cursor getCursorAfter() {
			return this.iterator.getCursorAfter();
		}

		@Override
		public int getSkippedResults() {
			return this.getSkippedResults();
		}

		@Override
		public QueryResultBatch.MoreResultsType getMoreResults() {
			return this.getMoreResults();
		}

	}

}
